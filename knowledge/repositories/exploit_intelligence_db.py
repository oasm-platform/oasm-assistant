"""
Exploit intelligence repository
Tracks exploit availability and active exploitation
"""
from typing import Optional, List, Dict
from sqlalchemy.orm import Session
from sqlalchemy import desc, and_
from data.database.models.exploit_intelligence import ExploitIntelligence


class ExploitIntelligenceRepository:
    """Repository for exploit intelligence operations"""

    def __init__(self, session: Session):
        self.session = session

    def get_by_cve(self, cve_id: str) -> List[ExploitIntelligence]:
        """Get all exploit intelligence for a CVE"""
        return self.session.query(ExploitIntelligence)\
            .filter(ExploitIntelligence.cve_id == cve_id)\
            .all()

    def has_public_exploit(self, cve_id: str) -> bool:
        """Check if public exploit is available"""
        exploits = self.session.query(ExploitIntelligence)\
            .filter(and_(
                ExploitIntelligence.cve_id == cve_id,
                ExploitIntelligence.public_poc_available == True
            ))\
            .first()

        return exploits is not None

    def is_actively_exploited(self, cve_id: str) -> bool:
        """Check if vulnerability is actively exploited"""
        exploit = self.session.query(ExploitIntelligence)\
            .filter(and_(
                ExploitIntelligence.cve_id == cve_id,
                ExploitIntelligence.is_actively_exploited == True
            ))\
            .first()

        return exploit is not None

    def is_in_cisa_kev(self, cve_id: str) -> bool:
        """Check if in CISA Known Exploited Vulnerabilities catalog"""
        exploit = self.session.query(ExploitIntelligence)\
            .filter(and_(
                ExploitIntelligence.cve_id == cve_id,
                ExploitIntelligence.cisa_kev == True
            ))\
            .first()

        return exploit is not None

    def get_epss_score(self, cve_id: str) -> Optional[float]:
        """Get EPSS (Exploit Prediction Scoring System) score"""
        exploit = self.session.query(ExploitIntelligence)\
            .filter(ExploitIntelligence.cve_id == cve_id)\
            .order_by(desc(ExploitIntelligence.epss_score))\
            .first()

        return exploit.epss_score if exploit else None

    def get_exploit_maturity(self, cve_id: str) -> Optional[str]:
        """Get highest exploit maturity level"""
        maturity_order = {"High": 4, "Functional": 3, "PoC": 2, "Unproven": 1}

        exploits = self.get_by_cve(cve_id)
        if not exploits:
            return None

        highest = max(exploits, key=lambda e: maturity_order.get(e.exploit_maturity, 0))
        return highest.exploit_maturity

    def calculate_exploit_multiplier(self, cve_id: str) -> float:
        """
        Calculate risk multiplier based on exploit availability

        Returns:
            Multiplier value (1.0 - 1.5)
        """
        multiplier = 1.0

        # Check CISA KEV (highest priority)
        if self.is_in_cisa_kev(cve_id):
            multiplier *= 1.5
            return multiplier

        # Check active exploitation
        if self.is_actively_exploited(cve_id):
            multiplier *= 1.5
            return multiplier

        # Check public exploit availability
        if self.has_public_exploit(cve_id):
            multiplier *= 1.4

        # Check EPSS score
        epss = self.get_epss_score(cve_id)
        if epss:
            if epss >= 0.5:  # High probability
                multiplier *= 1.3
            elif epss >= 0.2:  # Medium probability
                multiplier *= 1.2

        # Check exploit maturity
        maturity = self.get_exploit_maturity(cve_id)
        if maturity == "High" or maturity == "Functional":
            multiplier *= 1.2
        elif maturity == "PoC":
            multiplier *= 1.1

        return multiplier

    def get_actively_exploited_vulnerabilities(self) -> List[ExploitIntelligence]:
        """Get all actively exploited vulnerabilities"""
        return self.session.query(ExploitIntelligence)\
            .filter(ExploitIntelligence.is_actively_exploited == True)\
            .order_by(desc(ExploitIntelligence.exploitation_count))\
            .all()

    def get_cisa_kev_list(self) -> List[ExploitIntelligence]:
        """Get CISA KEV catalog entries"""
        return self.session.query(ExploitIntelligence)\
            .filter(ExploitIntelligence.cisa_kev == True)\
            .all()

    def create_exploit_intel(
        self,
        cve_id: str,
        exploit_source: Optional[str] = None,
        exploit_url: Optional[str] = None,
        exploit_maturity: Optional[str] = None,
        epss_score: Optional[float] = None,
        is_actively_exploited: bool = False,
        cisa_kev: bool = False,
        **kwargs
    ) -> ExploitIntelligence:
        """Create a new exploit intelligence entry"""
        intel = ExploitIntelligence(
            cve_id=cve_id,
            exploit_source=exploit_source,
            exploit_url=exploit_url,
            exploit_maturity=exploit_maturity,
            epss_score=epss_score,
            is_actively_exploited=is_actively_exploited,
            cisa_kev=cisa_kev,
            **kwargs
        )
        self.session.add(intel)
        self.session.commit()
        return intel
